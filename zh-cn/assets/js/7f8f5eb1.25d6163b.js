"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[338],{6192:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var i=t(5893),s=t(1151);const o={sidebar_position:3,title:"Data Models"},a=void 0,r={id:"elide/data-model",title:"Data Models",description:"This page is a description on how to create CRUD data models (create, read, update, and delete) in the backend",source:"@site/docs/elide/data-model.md",sourceDirName:"elide",slug:"/elide/data-model",permalink:"/astraios/zh-cn/docs/elide/data-model",draft:!1,unlisted:!1,editUrl:"https://github.com/paion-data/astraios/tree/master/docs/docs/elide/data-model.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Data Models"},sidebar:"tutorialSidebar",previous:{title:"Features",permalink:"/astraios/zh-cn/docs/elide/features"},next:{title:"Security",permalink:"/astraios/zh-cn/docs/elide/security"}},d={},l=[{value:"Annotations",id:"annotations",level:2},{value:"Exposing a Model as an Astraios Endpoint",id:"exposing-a-model-as-an-astraios-endpoint",level:2},{value:"Model Identifiers",id:"model-identifiers",level:2},{value:"Attributes vs Relationships",id:"attributes-vs-relationships",level:2},{value:"Model Properties or Fields",id:"model-properties-or-fields",level:2},{value:"Computed Attributes",id:"computed-attributes",level:2},{value:"Lifecycle Hooks",id:"lifecycle-hooks",level:2},{value:"Annotation Based Hooks",id:"annotation-based-hooks",level:3},{value:"Registered Function Hooks",id:"registered-function-hooks",level:3},{value:"Dependency Injection",id:"dependency-injection",level:2},{value:"Validation",id:"validation",level:2},{value:"Type Coercion",id:"type-coercion",level:2},{value:"Inheritance",id:"inheritance",level:2},{value:"API Versions",id:"api-versions",level:2},{value:"Philosophy",id:"philosophy",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["This page is a description on how to ",(0,i.jsx)(n.em,{children:"create"})," CRUD data models (create, read, update, and delete) in the backend\nusing Astraios. For more information on ",(0,i.jsx)(n.em,{children:"interacting"})," with an Astraios API, please see our\n",(0,i.jsx)(n.a,{href:"clientapis",children:"API usage documentation"}),". More information for creating analytic models can be found ",(0,i.jsx)(n.a,{href:"analytics",children:"here"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["Astraios generates its API entirely based on the concept of ",(0,i.jsx)(n.strong,{children:"data models"}),". Data models are JVM classes that\nrepresent both a concept to our application and the ",(0,i.jsx)(n.em,{children:"schema"})," of an exposed web service endpoint. Data models are\nintended to be a ",(0,i.jsx)(n.em,{children:"view"})," on top of the ",(0,i.jsx)(n.a,{href:"datastores",children:"data store"})," or the set of data stores which support our\nAstraios-based service."]}),"\n",(0,i.jsxs)(n.p,{children:["All Astraios models have an identifier field that identifies a unique instance of the model. Models are also\ncomposed of optional attributes and relationships. ",(0,i.jsx)(n.strong,{children:"Attribute"})," are properties of the model. ",(0,i.jsx)(n.strong,{children:"Relationships"})," are\nsimply links to other related Astraios models. Annotations are used to declare that a class is an Astraios model,\nthat a relationship exists between two models, to denote which field is the identifier field, and to\n",(0,i.jsx)(n.a,{href:"security",children:"secure the model"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"annotations",children:"Annotations"}),"\n",(0,i.jsxs)(n.p,{children:["Astraios has first class support for\n",(0,i.jsx)(n.a,{href:"http://www.oracle.com/technetwork/java/javaee/tech/persistence-jsp-140049.html",children:"JPA (Java Persistence API)"}),"\nannotations. These annotations serve double duty by both:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"describing the attributes, relationships, and id field of a model."}),"\n",(0,i.jsx)(n.li,{children:"provide an object relational mapping that can be used by an Astraios data store to persist the model."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Astraios makes use of the following JPA annotations: ",(0,i.jsx)(n.code,{children:"@OneToOne"}),", ",(0,i.jsx)(n.code,{children:"@OneToMany"}),", ",(0,i.jsx)(n.code,{children:"@ManyToOne"}),", ",(0,i.jsx)(n.code,{children:"@ManyToMany"}),", ",(0,i.jsx)(n.code,{children:"@Id"}),",\n",(0,i.jsx)(n.code,{children:"@EmbeddedId"}),", and ",(0,i.jsx)(n.code,{children:"@GeneratedValue"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If more information about JPA is need, please\n",(0,i.jsx)(n.a,{href:"http://www.oracle.com/technetwork/java/javaee/tech/persistence-jsp-140049.html",children:"review their documentation"})," or see\nour examples below."]}),"\n",(0,i.jsx)(n.p,{children:"However, JPA is not required and Astraios supports its own set of annotations for describing models:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Annotation Purpose"}),(0,i.jsx)(n.th,{children:"JPA"}),(0,i.jsx)(n.th,{children:"Non-JPA"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Expose a model in astraios"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@Include"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"To One Relationship"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"@OneToOne"}),", ",(0,i.jsx)(n.code,{children:"@ManyToOne"})]}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@ToOne"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"To Many Relationship"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"@OneToMany"}),", ",(0,i.jsx)(n.code,{children:"@ManyToMany"})]}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@ToMany"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Mark an identifier field"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"@Id"}),", ",(0,i.jsx)(n.code,{children:"@EmbeddedId"})]}),(0,i.jsx)(n.td,{})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Much of the Astraios per-model configuration is done via annotations. For a full description of all\nAstraios-supported annotations, please check out the annotation JavaDoc."}),"\n",(0,i.jsx)(n.h2,{id:"exposing-a-model-as-an-astraios-endpoint",children:"Exposing a Model as an Astraios Endpoint"}),"\n",(0,i.jsxs)(n.p,{children:["After creating a proper data model, we can expose it through Astraios by marking with with ",(0,i.jsx)(n.code,{children:"@Include"}),". Astraios\ngenerates its API as a ",(0,i.jsx)(n.em,{children:"graph"}),". This graph can only be traversed starting at a ",(0,i.jsx)(n.em,{children:"root"})," node. Rootable entities are\ndenoted by applying ",(0,i.jsx)(n.code,{children:"@Include"})," to the top-level of the class with the ",(0,i.jsx)(n.strong,{children:"rootLevel"})," property unset or set to ",(0,i.jsx)(n.code,{children:"true"}),".\nNon-rootable entities can be accessed only as relationships through the graph."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"@Entity\n@Include\npublic class Author {\n\n    @Id\n    @GeneratedValue(strategy=GenerationType.AUTO)\n    private Long id;\n\n    private String name;\n\n    @ManyToMany\n    private Set<Book> books;\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"@Entity\n@Include(rootLevel = false)\npublic class Book {\n    @Id\n    @GeneratedValue(strategy=GenerationType.AUTO)\n    private Long id;\n\n    private String title;\n\n    @ManyToMany\n    private Set<Author> authors;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Considering the example above, we have a full data model that exposes a specific graph. Namely, a root node of the\ntype ",(0,i.jsx)(n.code,{children:"Author"})," and a bi-directional relationship from ",(0,i.jsx)(n.code,{children:"Author"})," to ",(0,i.jsx)(n.code,{children:"Book"}),". That is, one can access all ",(0,i.jsx)(n.code,{children:"Author"}),"\nobjects directly, but must go ",(0,i.jsx)(n.em,{children:"through"})," an author to see information about any specific ",(0,i.jsx)(n.code,{children:"Book"})," object."]}),"\n",(0,i.jsx)(n.h2,{id:"model-identifiers",children:"Model Identifiers"}),"\n",(0,i.jsx)(n.p,{children:"Every model in Astraios must have an ID. This is a requirement of both the JSON-API specification and Astraios's\nGraphQL API. Identifiers can be assigned by the persistence layer automatically or the client. Astraios must know\ntwo things:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["What field is the ID of the model. This is determined by the ",(0,i.jsx)(n.code,{children:"@Id"})," or ",(0,i.jsx)(n.code,{children:"@EmbeddedId"})," annotation."]}),"\n",(0,i.jsxs)(n.li,{children:["Whether the persistence layer is assigning the ID or not. This is determined by the presence or absence of the\n",(0,i.jsx)(n.code,{children:"@GeneratedValue"})," annotation."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Identifier fields in Astraios are typically integers, longs, strings, or UUIDs. It is also possible to have\ncomposite/compound ID fields composed of multiple fields. For example, the following identifier type includes three\nfields that together create a primary key:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"@Data\n@Embeddable\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Address implements Serializable {\n    private long number;\n    private String street;\n    private long zipCode;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This new compound ID type can then be referenced in an Astraios model identifier like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"@Data\n@Entity\n@Include(rootLevel = true)\npublic class Building {\n    @EmbeddedId\n    private Address address;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Because JSON-API requires all ID fields to be Strings, composite/compound IDs require the developer to register an\nAstraios ",(0,i.jsx)(n.code,{children:"Serde"})," to serialize and deserialize the ID type to a String. For example, the following ",(0,i.jsx)(n.code,{children:"Serde"})," will\nencode/decode an ",(0,i.jsx)(n.code,{children:"Address"})," as a base64 encoded string:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@ElideTypeConverter(type = Address.class, name = "Address")\npublic class AddressSerde implements Serde<String, Address> {\n\n    private static final Pattern ADDRESS_PATTERN =\n            Pattern.compile("Address\\\\(number=(\\\\d+), street=([a-zA-Z0-9 ]+), zipCode=(\\\\d+)\\\\)");\n\n    @Override\n    public Address deserialize(String val) {\n        byte[] decodedBytes = Base64.getDecoder().decode(val);\n        String decodedString = new String(decodedBytes);\n\n        Matcher matcher = ADDRESS_PATTERN.matcher(decodedString);\n        if (! matcher.matches()) {\n            throw new InvalidValueException(decodedString);\n        }\n        long number = Long.valueOf(matcher.group(1));\n        String street = matcher.group(2);\n        long zipCode = Long.valueOf(matcher.group(3));\n\n        Address address = new Address(number, street, zipCode);\n\n        return address;\n    }\n\n    @Override\n    public String serialize(Address val) {\n        return Base64.getEncoder().encodeToString(val.toString().getBytes());\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["More information about ",(0,i.jsx)(n.code,{children:"Serde"})," and user defined types can be found ",(0,i.jsx)(n.a,{href:"clientapis#type-coercion",children:"here"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"attributes-vs-relationships",children:"Attributes vs Relationships"}),"\n",(0,i.jsx)(n.p,{children:"Astraios distinguishes between attributes and relationships in a data model:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Relationships"})," are links from one model to another. They can be traversed directly through the API. If the\nrelationship represents a collection, they can also be sorted, filtered, and paginated. Relationships must be\nexplicitly marked with an annotation (for example - ",(0,i.jsx)(n.code,{children:"@ToMany"}),") in the model and can be bidirectional or\nunidirectional."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Attributes"})," are properties of a model. They can be primitive types, objects, or collections of objects or\nprimitives. Attributes which are collections cannot be sorted, filtered, or paginated in the API. Complex\nattributes (collections or objects) cannot be used in a filter predicate. Attributes are not marked with\nannotations in Astraios."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"model-properties-or-fields",children:"Model Properties or Fields"}),"\n",(0,i.jsxs)(n.p,{children:["An Astraios model can be described using properties (getter and setter functions) or fields (class member variables)\nbut ",(0,i.jsx)(n.em,{children:"not"})," both on the same entity. For any given entity, Astraios looks at whether ",(0,i.jsx)(n.code,{children:"@Id"})," or ",(0,i.jsx)(n.code,{children:"@EmbeddedId"})," is a\nproperty or field to determine the access mode (property or field) for that entity. All public properties and all\nfields are exposed through the Astraios API if they are not explicitly marked ",(0,i.jsx)(n.code,{children:"@Transient"})," or ",(0,i.jsx)(n.code,{children:"@Exclude"}),".\n",(0,i.jsx)(n.code,{children:"@Transient"})," allows a field to be ignored by both Astraios and an underlying persistence store while ",(0,i.jsx)(n.code,{children:"@Exclude"}),"\nallows a field to exist in the underlying persistence layer without exposing it through the Astraios API."]}),"\n",(0,i.jsx)(n.h2,{id:"computed-attributes",children:"Computed Attributes"}),"\n",(0,i.jsx)(n.p,{children:"A computed attribute is an entity attribute whose value is computed in code rather than fetched from a data store."}),"\n",(0,i.jsxs)(n.p,{children:["Astraios supports computed properties by way of the ",(0,i.jsx)(n.code,{children:"@ComputedAttribute"})," and ",(0,i.jsx)(n.code,{children:"@ComputedRelationship"})," annotations.\nThese are useful if our data store is also tied to your Astraios view data model. For instance, if we mark a field\n",(0,i.jsx)(n.code,{children:"@Transient"}),", a data store such as Hibernate will ignore it. In the absence of the ",(0,i.jsx)(n.code,{children:"@Computed*"})," attributes, Astraios\nwill too. However, when applying a computed property attribute, Astraios will expose this field anyway."]}),"\n",(0,i.jsxs)(n.p,{children:["A computed attribute can perform arbitrary computation and is exposed through Astraios as a typical attribute. In\nthe case below, this will create an attribute called ",(0,i.jsx)(n.code,{children:"myComputedAttribute"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Entity\n@Include\npublic class Book {\n\n    ...\n\n    @Transient\n    @ComputedAttribute\n    public String getMyComputedAttribute(RequestScope requestScope) {\n        return "My special string stored only in the JVM!";\n    }\n\n    ...\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The same principles are analogous to ",(0,i.jsx)(n.code,{children:"@ComputedRelationship"}),"s."]}),"\n",(0,i.jsx)(n.h2,{id:"lifecycle-hooks",children:"Lifecycle Hooks"}),"\n",(0,i.jsx)(n.p,{children:"Lifecycle hooks allow custom business logic (defined in functions) to be invoked during CRUD operations at four\ndistinct phases of the client request:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Pre Security"})," - Executed immediate prior to Astraios security check evaluation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Pre Flush"})," - Executed immediate prior to Astraios flushing the transaction. This is when database calls are\nfirst sent to the database."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Pre Commit"})," - Executed immediately prior to transaction commit but after all security checks have been evaluated."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Post Commit"})," - Executed immediately after transaction commit."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"There are two mechanisms to enable lifecycle hooks on a particular model:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The simplest mechanism is to ",(0,i.jsx)(n.a,{href:"#annotation-based-hooks",children:"decorate"})," the Astraios model or model fields with the life\ncycle hook function class and the conditions of when to invoke it."]}),"\n",(0,i.jsxs)(n.li,{children:["Lifecycle hook functions can also be ",(0,i.jsx)(n.a,{href:"#registered-function-hooks",children:"registered"})," with the ",(0,i.jsx)(n.code,{children:"EntityDictionary"})," when\ninitializing Astraios."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Life cycle hooks are simply functions that conform to the following interface:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"/**\n * Function which will be invoked for Astraios lifecycle triggers\n *\n * @param <T> The astraios entity type associated with this callback.\n */\n@FunctionalInterface\npublic interface LifeCycleHook<T> {\n\n    /**\n     * Run for a lifecycle event.\n     *\n     * @param operation CREATE, UPDATE, or DELETE\n     * @param phase PRESECURITY, PREFLUSH, PRECOMMIT or POSTCOMMIT\n     * @param astraiosEntity The entity that triggered the event\n     * @param requestScope The request scope\n     * @param changes Optionally, the changes that were made to the entity\n     */\n    void execute(\n            LifeCycleHookBinding.Operation operation,\n            LifeCycleHookBinding.TransactionPhase phase,\n            T astraiosEntity,\n            RequestScope requestScope,\n            Optional<ChangeSpec> changes\n    );\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"annotation-based-hooks",children:"Annotation Based Hooks"}),"\n",(0,i.jsxs)(n.p,{children:["Model fields can be decorated with a ",(0,i.jsx)(n.code,{children:"LifeCycleHookBinding"})," annotation. The annotation provides the following\ninformation:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"The hook function to invoke."}),"\n",(0,i.jsx)(n.li,{children:"The model operation (CREATE, UPDATE, or DELETE) that triggers the hook."}),"\n",(0,i.jsx)(n.li,{children:"The transaction phase of when to trigger the hook (PRESECURITY, PREFLUSH, PRECOMMIT, or POSTCOMMIT)."}),"\n",(0,i.jsx)(n.li,{children:"For class level triggers, whether or not the hook should be called for each impacted field or exactly once for\nthe class."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'class Publisher {\n\n    @Id\n    private long id;\n\n    @OneToMany(mappedBy = "publisher")\n    @LifeCycleHookBinding(operation = UPDATE, phase = PRECOMMIT, hook = PublisherUpdateHook.class)\n    private Set<Book> books;\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"registered-function-hooks",children:"Registered Function Hooks"}),"\n",(0,i.jsx)(n.p,{children:"Lifecycle hooks can be registered in Astraios directly without an explicit annotation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// Register a lifecycle hook for deletes on the model Book. Call exactly once.\ndictionary.bindTrigger(Book.class, DELETE, PRESECURITY, hook, false);\n\n// Register a lifecycle hook for updates on the Book model's title attribute\ndictionary.bindTrigger(Book.class, \"title\", UPDATE, POSTCOMMIT, hook);\n\n// Register a lifecycle hook for updates on _any_ of the Book model's attributes\ndictionary.bindTrigger(Book.class, UPDATE, POSTCOMMIT, hook, true);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"dependency-injection",children:"Dependency Injection"}),"\n",(0,i.jsx)(n.p,{children:"Astraios does not depend on a specific dependency injection framework. However, Astraios can inject entity models,\nsecurity checks, lifecycle hooks, and serdes during their construction. Astraios provides a framework agnostic,\nfunctional interface to inject entity models:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"/**\n * Abstraction around dependency injection.\n */\n@FunctionalInterface\npublic interface Injector {\n\n    /**\n     * Inject an Astraios object.\n     *\n     * @param entity object to inject\n     */\n    void inject(Object entity);\n\n    /**\n     * Instantiates a new instance of a class using the DI framework.\n     *\n     * @param cls The class to instantiate.\n     * @return An instance of the class.\n     */\n    default <T> T instantiate(Class<T> cls) {\n        try {\n            return cls.newInstance();\n        } catch (InstantiationException | IllegalAccessException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["An implementation of this interface can be passed to the ",(0,i.jsx)(n.code,{children:"EntityDictionary"})," during its construction:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"EntityDictionary dictionary = new EntityDictionary(\n        PermissionExpressions.getExpressions(),\n        (obj) -> injector.inject(obj)\n);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In Astraios, dependency injection is set up using Jetty's ",(0,i.jsx)(n.code,{children:"ServiceLocator"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"validation",children:"Validation"}),"\n",(0,i.jsxs)(n.p,{children:["Data models can be validated using ",(0,i.jsx)(n.a,{href:"http://beanvalidation.org/1.0/spec/",children:"bean validation"}),". This requires ",(0,i.jsx)(n.em,{children:"JSR303"}),"\ndata model annotations and wiring in a bean validator in the ",(0,i.jsx)(n.code,{children:"DataStore"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"type-coercion",children:"Type Coercion"}),"\n",(0,i.jsxs)(n.p,{children:["Type coercion between the API and underlying data model has common support across JSON-API and GraphQL and is\ncovered ",(0,i.jsx)(n.a,{href:"clientapis#type-coercion",children:"here"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"inheritance",children:"Inheritance"}),"\n",(0,i.jsx)(n.p,{children:"Astraios supports two kinds of inheritance:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Non-entity inheritance via the JPA annotation ",(0,i.jsx)(n.code,{children:"@MappedSuperclass"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Entity inheritance via the JPA annotation ",(0,i.jsx)(n.code,{children:"@Inheritance"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Entity inheritance has a few caveats:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Only the ",(0,i.jsx)(n.code,{children:"InheritanceType.JOINED"})," and ",(0,i.jsx)(n.code,{children:"InheritanceType.SINGLE_TABLE"})," strategies are supported."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Entity relationships whose type is a superclass have different behavior in JSON-API and GraphQL:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"JSON-API will return the type and attributes of the subclass (as well as the super class)."}),"\n",(0,i.jsx)(n.li,{children:"GraphQL will return the type and attributes of the superclass only."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"api-versions",children:"API Versions"}),"\n",(0,i.jsxs)(n.p,{children:["Astraios models can be bound to a specific API version. Once bound, the models will only be visible to API requests\nthat ask for the specific version. API versions are bound by creating a package-info.java file with the\n",(0,i.jsx)(n.code,{children:"ApiVersion"})," annotation:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@ApiVersion(version = "1.0")\npackage example.models;\n\nimport com.yahoo.elide.annotation.ApiVersion;\n'})}),"\n",(0,i.jsx)(n.p,{children:"API versioning is optional configuration. By default, all models have no implicit version. The API client is also\nnot required to provide a version in its request.By adding a version to one or more packages however, the versioned\nmodels will only be visible when the client provides the corresponding version in its request."}),"\n",(0,i.jsxs)(n.p,{children:["There is an important caveat when using API versioning with JPA models.JPA does not allow two ",(0,i.jsx)(n.code,{children:"Entity"})," classes to\nshare the same name - even if they belong to different packages. To work around this, we can either:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Rename the class (class BookV2) but preserve the Astraios model (",(0,i.jsx)(n.code,{children:'@Include(type = "book")'}),") and database table\n(",(0,i.jsx)(n.code,{children:'@Table(name = "book")'}),") names."]}),"\n",(0,i.jsxs)(n.li,{children:["Rename the entity name (",(0,i.jsx)(n.code,{children:'@Entity(name = "BookV2")'}),") but preserve the Astraios model (",(0,i.jsx)(n.code,{children:'@Include(type = "book")'}),")\nand class (class Book) names."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Details of how to construct client queries for a specific version can be found ",(0,i.jsx)(n.a,{href:"clientapis#api-versioning",children:"here"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"philosophy",children:"Philosophy"}),"\n",(0,i.jsxs)(n.p,{children:["Data models are intended to be a ",(0,i.jsx)(n.em,{children:"view"})," on top of the ",(0,i.jsx)(n.a,{href:"datastores",children:"data store"})," or the set of data stores which\nsupport our Astraios-based service. While other JPA-based workflows often encourage writing data models that exactly\nmatch the underlying schema of the data store, we propose a strategy of isolation on per-service basis. Namely, we\nrecommend creating a data model that only supports precisely the bits of data we need from our underlying schema.\nOften times there will be no distinction when first building our systems. However, as our systems scale and we\ndevelop multiple services with overlapping data store requirements, isolation often serves as an effective tool to\n",(0,i.jsx)(n.strong,{children:"reduce interdependency"})," among services and ",(0,i.jsx)(n.strong,{children:"maximize the separation of concern"}),". Overall, while models can\ncorrespond to our underlying data store schema as a one-to-one representation, it's not always strictly necessary\nand sometimes even undesirable."]}),"\n",(0,i.jsxs)(n.p,{children:["As an example, let's consider a situation where we have two Astraios-based microservices: one for our application\nbackend and another for authentication (suppose account creation is performed out-of-band for this example).\nAssuming both of these rely on a common data store, they'll both likely want to recognize the same underlying ",(0,i.jsx)(n.em,{children:"User"}),"\ntable. However, it's quite likely that the authentication service will only ever require information about user\n",(0,i.jsx)(n.strong,{children:"credentials"})," and the application service will likely only ever need user ",(0,i.jsx)(n.strong,{children:"metadata"}),". More concretely, you could\nhave a system that looks like the following:"]}),"\n",(0,i.jsx)(n.p,{children:"Table schema:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"id\nuserName\npassword\nfirstName\nlastName\n"})}),"\n",(0,i.jsx)(n.p,{children:"Authentication schema:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"id\nuserName\npassword\n"})}),"\n",(0,i.jsx)(n.p,{children:"Application schema:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"id\nuserName\nfirstName\nlastName\n"})}),"\n",(0,i.jsxs)(n.p,{children:["While we could certainly just use the raw table schema directly (represented as a JPA-annotated data model) and\nreuse it across services, the point is that we may be over-exposing information in areas where we may not want to.\nIn the case of the ",(0,i.jsx)(n.em,{children:"User"})," object, it's quite apparent that the application service should never be ",(0,i.jsx)(n.em,{children:"capable"})," of\naccidentally exposing a user's private credentials. By creating isolated views per-service on top of common data\nstores, we sacrifice a small bit of ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself",children:"DRY principles"})," for much\nbetter isolation and a more targeted service. Likewise, if the underlying table schema is updated with a new field\nthat neither one of these services needs, neither service requires a rebuild and redeploy since the change is\nirrelevant to their function."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A note about microservices:"})," Another common technique to building microservices is for each service to have its\nown set of data stores entirely independent from other services (i.e. no shared overlap); these data stores are then\nsynced by other services as necessary through a messaging bus. If our system architecture calls for such a model,\nit's quite likely we will follow the same pattern we have outlined here with ",(0,i.jsx)(n.em,{children:"one key difference"}),": the underlying\ntable schema for our ",(0,i.jsx)(n.em,{children:"individual service's data store"})," will likely be exactly the same as our service's model\nrepresenting it. However, overall, the net effect is the same since only the relevant information delivered over the\nbus is stored in our service's schema. In fact, this model is arguably more robust in the sense that if one data\nstore fails not all services necessarily fail."]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>a});var i=t(7294);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);